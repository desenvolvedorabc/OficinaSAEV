"""
üìä SAEV - Sistema de An√°lise Educacional do Esp√≠rito Santo
üéØ Galeria de Pain√©is com Filtros Avan√ßados

Aplicativo Streamlit para visualiza√ß√£o interativa dos dados SAEV
com m√∫ltiplos pain√©is e filtros din√¢micos.
"""

import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import duckdb
import numpy as np
from datetime import datetime

# =================== CONFIGURA√á√ÉO DA P√ÅGINA ===================
st.set_page_config(
    page_title="SAEV - Pain√©is Educacionais",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# =================== FUN√á√ïES AUXILIARES ===================

def conectar_banco():
    """Conecta ao banco DuckDB e retorna a conex√£o"""
    try:
        con = duckdb.connect('db/avaliacao_prod.duckdb', read_only=True)
        return con
    except Exception as e:
        st.error(f"‚ùå Erro ao conectar ao banco: {e}")
        return None

@st.cache_data
def carregar_opcoes_filtros():
    """Carrega todas as op√ß√µes dispon√≠veis para os filtros"""
    con = conectar_banco()
    if not con:
        return {}
    
    try:
        opcoes = {}
        
        # Anos
        opcoes['anos'] = [row[0] for row in con.execute(
            "SELECT DISTINCT AVA_ANO FROM fato_resposta_aluno ORDER BY AVA_ANO"
        ).fetchall()]
        
        # Munic√≠pios
        opcoes['municipios'] = [row[0] for row in con.execute(
            "SELECT DISTINCT MUN_NOME FROM fato_resposta_aluno ORDER BY MUN_NOME"
        ).fetchall()]
        
        # Escolas
        opcoes['escolas'] = [row[0] for row in con.execute(
            "SELECT DISTINCT e.ESC_NOME FROM dim_escola e INNER JOIN fato_resposta_aluno f ON e.ESC_INEP = f.ESC_INEP ORDER BY e.ESC_NOME"
        ).fetchall()]
        
        # Disciplinas
        opcoes['disciplinas'] = [row[0] for row in con.execute(
            "SELECT DISTINCT DIS_NOME FROM fato_resposta_aluno ORDER BY DIS_NOME"
        ).fetchall()]
        
        # S√©ries
        opcoes['series'] = [row[0] for row in con.execute(
            "SELECT DISTINCT SER_NOME FROM fato_resposta_aluno ORDER BY SER_NUMBER"
        ).fetchall()]
        
        # Testes
        opcoes['testes'] = [row[0] for row in con.execute(
            "SELECT DISTINCT TES_NOME FROM fato_resposta_aluno ORDER BY TES_NOME"
        ).fetchall()]
        
        con.close()
        return opcoes
        
    except Exception as e:
        st.error(f"‚ùå Erro ao carregar op√ß√µes: {e}")
        con.close()
        return {}

def construir_query_base(filtros):
    """Constr√≥i a query base com os filtros aplicados"""
    query = """
    SELECT 
        f.*,
        e.ESC_NOME,
        d.MTI_DESCRITOR
    FROM fato_resposta_aluno f
    LEFT JOIN dim_escola e ON f.ESC_INEP = e.ESC_INEP
    LEFT JOIN dim_descritor d ON f.MTI_CODIGO = d.MTI_CODIGO
    WHERE 1=1
    """
    
    params = []
    
    if filtros['anos']:
        query += f" AND AVA_ANO IN ({','.join(['?' for _ in filtros['anos']])})"
        params.extend(filtros['anos'])
    
    if filtros['municipios']:
        query += f" AND MUN_NOME IN ({','.join(['?' for _ in filtros['municipios']])})"
        params.extend(filtros['municipios'])
    
    if filtros['escolas']:
        query += f" AND e.ESC_NOME IN ({','.join(['?' for _ in filtros['escolas']])})"
        params.extend(filtros['escolas'])
    
    if filtros['disciplinas']:
        query += f" AND DIS_NOME IN ({','.join(['?' for _ in filtros['disciplinas']])})"
        params.extend(filtros['disciplinas'])
    
    if filtros['series']:
        query += f" AND SER_NOME IN ({','.join(['?' for _ in filtros['series']])})"
        params.extend(filtros['series'])
    
    if filtros['testes']:
        query += f" AND TES_NOME IN ({','.join(['?' for _ in filtros['testes']])})"
        params.extend(filtros['testes'])
    
    return query, params

@st.cache_data
def carregar_dados_filtrados(filtros):
    """Carrega dados com filtros aplicados"""
    con = conectar_banco()
    if not con:
        return pd.DataFrame()
    
    try:
        query, params = construir_query_base(filtros)
        df = con.execute(query, params).fetchdf()
        con.close()
        return df
    except Exception as e:
        st.error(f"‚ùå Erro ao carregar dados: {e}")
        con.close()
        return pd.DataFrame()

# =================== INTERFACE DOS FILTROS ===================

def criar_filtros():
    """Cria a sidebar com todos os filtros"""
    st.sidebar.header("üîç Filtros de An√°lise")
    st.sidebar.markdown("---")
    
    # Carregar op√ß√µes
    opcoes = carregar_opcoes_filtros()
    if not opcoes:
        st.sidebar.error("‚ùå N√£o foi poss√≠vel carregar as op√ß√µes de filtro")
        return {}
    
    # Inicializar estados dos bot√µes "Todos" se n√£o existirem
    if "todos_municipios_clicked" not in st.session_state:
        st.session_state.todos_municipios_clicked = False
    if "todos_escolas_clicked" not in st.session_state:
        st.session_state.todos_escolas_clicked = False
    
    filtros = {}
    
    # Filtro Ano
    st.sidebar.subheader("üìÖ Ano")
    filtros['anos'] = st.sidebar.multiselect(
        "Selecione os anos:",
        options=opcoes['anos'],
        default=[],
        key="filtro_anos"
    )
    
    # Filtro Munic√≠pio
    st.sidebar.subheader("üèôÔ∏è Munic√≠pio")
    col1, col2 = st.sidebar.columns([3, 1])
    
    # Verificar se bot√£o "Todos" foi clicado
    default_municipios = opcoes['municipios'] if st.session_state.todos_municipios_clicked else []
    
    with col1:
        filtros['municipios'] = st.sidebar.multiselect(
            "Selecione os munic√≠pios:",
            options=opcoes['municipios'],
            default=default_municipios,
            key="filtro_municipios"
        )
    with col2:
        if st.sidebar.button("Todos", key="btn_todos_municipios"):
            st.session_state.todos_municipios_clicked = True
            st.rerun()
    
    # Filtro Escola
    st.sidebar.subheader("üè´ Escola")
    col1, col2 = st.sidebar.columns([3, 1])
    
    # Verificar se bot√£o "Todos" foi clicado
    default_escolas = opcoes['escolas'] if st.session_state.todos_escolas_clicked else []
    
    with col1:
        filtros['escolas'] = st.sidebar.multiselect(
            "Selecione as escolas:",
            options=opcoes['escolas'],
            default=default_escolas,
            key="filtro_escolas"
        )
    with col2:
        if st.sidebar.button("Todos", key="btn_todos_escolas"):
            st.session_state.todos_escolas_clicked = True
            st.rerun()
    
    # Filtro Disciplina
    st.sidebar.subheader("üìö Disciplina")
    filtros['disciplinas'] = st.sidebar.multiselect(
        "Selecione as disciplinas:",
        options=opcoes['disciplinas'],
        default=[],
        key="filtro_disciplinas"
    )
    
    # Filtro S√©rie
    st.sidebar.subheader("üéì S√©rie")
    filtros['series'] = st.sidebar.multiselect(
        "Selecione as s√©ries:",
        options=opcoes['series'],
        default=[],
        key="filtro_series"
    )
    
    # Filtro Teste
    st.sidebar.subheader("üìù Teste")
    filtros['testes'] = st.sidebar.multiselect(
        "Selecione os testes:",
        options=opcoes['testes'],
        default=[],
        key="filtro_testes"
    )
    
    st.sidebar.markdown("---")
    
    # Bot√£o Limpar Filtros
    if st.sidebar.button("üßπ Limpar Todos os Filtros", type="secondary"):
        # Limpar estados dos bot√µes "Todos"
        st.session_state.todos_municipios_clicked = False
        st.session_state.todos_escolas_clicked = False
        # Limpar filtros
        for key in list(st.session_state.keys()):
            if key.startswith('filtro_'):
                del st.session_state[key]
        st.rerun()
    
    return filtros

# =================== PAIN√âIS ===================

def painel_visao_geral(df):
    """Painel 1: Vis√£o Geral dos Dados"""
    st.header("üìä Painel 1: Vis√£o Geral dos Dados")
    
    if df.empty:
        st.warning("‚ö†Ô∏è Nenhum dado encontrado com os filtros selecionados.")
        return
    
    # M√©tricas principais
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        total_alunos = df['ALU_ID'].nunique()
        st.metric("üë®‚Äçüéì Total de Alunos", f"{total_alunos:,}")
    
    with col2:
        total_escolas = df['ESC_INEP'].nunique()
        st.metric("üè´ Total de Escolas", f"{total_escolas:,}")
    
    with col3:
        total_municipios = df['MUN_NOME'].nunique()
        st.metric("üèôÔ∏è Total de Munic√≠pios", f"{total_municipios:,}")
    
    with col4:
        total_testes = df['TES_NOME'].nunique()
        st.metric("üìù Total de Testes", f"{total_testes:,}")
    
    st.markdown("---")
    
    # Layout em duas colunas
    col1, col2 = st.columns(2)
    
    with col1:
        # N√∫mero de alunos por munic√≠pio
        st.subheader("üë®‚Äçüéì Alunos por Munic√≠pio")
        alunos_mun = df.groupby('MUN_NOME')['ALU_ID'].nunique().reset_index()
        alunos_mun = alunos_mun.sort_values('ALU_ID', ascending=False).head(15)
        
        fig = px.bar(
            alunos_mun, 
            x='ALU_ID', 
            y='MUN_NOME',
            orientation='h',
            title="Top 15 Munic√≠pios por N√∫mero de Alunos",
            labels={'ALU_ID': 'N√∫mero de Alunos', 'MUN_NOME': 'Munic√≠pio'}
        )
        fig.update_layout(height=400)
        st.plotly_chart(fig, use_container_width=True)
        
        # Munic√≠pios com maiores taxas de acerto
        st.subheader("üèÜ Munic√≠pios - Maiores Taxas de Acerto")
        taxa_mun = df.groupby(['MUN_NOME', 'DIS_NOME', 'SER_NOME']).agg({
            'ACERTO': 'sum',
            'ERRO': 'sum'
        }).reset_index()
        taxa_mun['total_questoes'] = taxa_mun['ACERTO'] + taxa_mun['ERRO']
        taxa_mun['taxa_acerto'] = (taxa_mun['ACERTO'] / taxa_mun['total_questoes'] * 100).round(2)
        
        top_municipios = taxa_mun.groupby('MUN_NOME')['taxa_acerto'].mean().reset_index()
        top_municipios = top_municipios.sort_values('taxa_acerto', ascending=False).head(10)
        
        fig = px.bar(
            top_municipios,
            x='taxa_acerto',
            y='MUN_NOME',
            orientation='h',
            title="Top 10 Munic√≠pios - Taxa de Acerto M√©dia",
            labels={'taxa_acerto': 'Taxa de Acerto (%)', 'MUN_NOME': 'Munic√≠pio'},
            color='taxa_acerto',
            color_continuous_scale='RdYlGn'
        )
        fig.update_layout(height=400)
        st.plotly_chart(fig, use_container_width=True)
    
    with col2:
        # N√∫mero de testes por disciplina
        st.subheader("üìù Testes por Disciplina")
        testes_disc = df.groupby('DIS_NOME')['TES_NOME'].nunique().reset_index()
        
        fig = px.pie(
            testes_disc,
            values='TES_NOME',
            names='DIS_NOME',
            title="Distribui√ß√£o de Testes por Disciplina"
        )
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)
        
        # Taxa de acerto por disciplina e s√©rie
        st.subheader("üìà Taxa de Acerto por Disciplina e S√©rie")
        taxa_disc_serie = df.groupby(['DIS_NOME', 'SER_NOME']).agg({
            'ACERTO': 'sum',
            'ERRO': 'sum'
        }).reset_index()
        taxa_disc_serie['total_questoes'] = taxa_disc_serie['ACERTO'] + taxa_disc_serie['ERRO']
        taxa_disc_serie['taxa_acerto'] = (taxa_disc_serie['ACERTO'] / taxa_disc_serie['total_questoes'] * 100).round(2)
        
        fig = px.bar(
            taxa_disc_serie,
            x='SER_NOME',
            y='taxa_acerto',
            color='DIS_NOME',
            title="Taxa de Acerto por S√©rie e Disciplina",
            labels={'taxa_acerto': 'Taxa de Acerto (%)', 'SER_NOME': 'S√©rie', 'DIS_NOME': 'Disciplina'},
            barmode='group'
        )
        fig.update_layout(height=400, xaxis_tickangle=-45)
        st.plotly_chart(fig, use_container_width=True)

def painel_taxas_acerto(df):
    """Painel 2: Gr√°ficos com Taxa de Acerto"""
    st.header("üìà Painel 2: Taxa de Acerto - An√°lises Detalhadas")
    
    if df.empty:
        st.warning("‚ö†Ô∏è Nenhum dado encontrado com os filtros selecionados.")
        return
    
    # Calcular taxas de acerto
    df['taxa_acerto'] = (df['ACERTO'] / (df['ACERTO'] + df['ERRO']) * 100)
    
    # Layout em abas
    tab1, tab2, tab3, tab4 = st.tabs([
        "üèôÔ∏è Por Munic√≠pio", 
        "üè´ Por Escola", 
        "üìö Por Disciplina", 
        "üéØ Por Descritor"
    ])
    
    with tab1:
        st.subheader("Taxa de Acerto por Munic√≠pio")
        
        # Agrupamento por munic√≠pio
        taxa_municipio = df.groupby(['MUN_NOME', 'DIS_NOME']).agg({
            'ACERTO': 'sum',
            'ERRO': 'sum'
        }).reset_index()
        taxa_municipio['total_questoes'] = taxa_municipio['ACERTO'] + taxa_municipio['ERRO']
        taxa_municipio['taxa_acerto'] = (taxa_municipio['ACERTO'] / taxa_municipio['total_questoes'] * 100).round(2)
        
        # Gr√°fico de barras por munic√≠pio
        fig = px.bar(
            taxa_municipio,
            x='MUN_NOME',
            y='taxa_acerto',
            color='DIS_NOME',
            title="Taxa de Acerto por Munic√≠pio e Disciplina",
            labels={'taxa_acerto': 'Taxa de Acerto (%)', 'MUN_NOME': 'Munic√≠pio'},
            barmode='group'
        )
        fig.update_layout(height=500, xaxis_tickangle=-45)
        st.plotly_chart(fig, use_container_width=True)
        
        # Heatmap por munic√≠pio e s√©rie
        col1, col2 = st.columns(2)
        with col1:
            taxa_mun_serie = df.groupby(['MUN_NOME', 'SER_NOME']).agg({
                'ACERTO': 'sum',
                'ERRO': 'sum'
            }).reset_index()
            taxa_mun_serie['taxa_acerto'] = (taxa_mun_serie['ACERTO'] / (taxa_mun_serie['ACERTO'] + taxa_mun_serie['ERRO']) * 100).round(2)
            
            # Pivot para heatmap
            heatmap_data = taxa_mun_serie.pivot(index='MUN_NOME', columns='SER_NOME', values='taxa_acerto')
            
            fig = px.imshow(
                heatmap_data,
                title="Heatmap: Taxa de Acerto por Munic√≠pio e S√©rie",
                aspect="auto",
                color_continuous_scale='RdYlGn'
            )
            fig.update_layout(height=400)
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            # Ranking de munic√≠pios
            ranking_mun = taxa_municipio.groupby('MUN_NOME')['taxa_acerto'].mean().reset_index()
            ranking_mun = ranking_mun.sort_values('taxa_acerto', ascending=False).head(15)
            
            fig = px.bar(
                ranking_mun,
                x='taxa_acerto',
                y='MUN_NOME',
                orientation='h',
                title="Ranking: Top 15 Munic√≠pios",
                labels={'taxa_acerto': 'Taxa de Acerto M√©dia (%)', 'MUN_NOME': 'Munic√≠pio'},
                color='taxa_acerto',
                color_continuous_scale='RdYlGn'
            )
            fig.update_layout(height=400)
            st.plotly_chart(fig, use_container_width=True)
    
    with tab2:
        st.subheader("Taxa de Acerto por Escola")
        
        # Agrupamento por escola
        taxa_escola = df.groupby(['ESC_NOME', 'DIS_NOME', 'MUN_NOME']).agg({
            'ACERTO': 'sum',
            'ERRO': 'sum'
        }).reset_index()
        taxa_escola['total_questoes'] = taxa_escola['ACERTO'] + taxa_escola['ERRO']
        taxa_escola['taxa_acerto'] = (taxa_escola['ACERTO'] / taxa_escola['total_questoes'] * 100).round(2)
        
        # Top escolas
        top_escolas = taxa_escola.groupby('ESC_NOME')['taxa_acerto'].mean().reset_index()
        top_escolas = top_escolas.sort_values('taxa_acerto', ascending=False).head(20)
        
        fig = px.bar(
            top_escolas,
            x='taxa_acerto',
            y='ESC_NOME',
            orientation='h',
            title="Top 20 Escolas - Taxa de Acerto M√©dia",
            labels={'taxa_acerto': 'Taxa de Acerto (%)', 'ESC_NOME': 'Escola'},
            color='taxa_acerto',
            color_continuous_scale='RdYlGn'
        )
        fig.update_layout(height=600)
        st.plotly_chart(fig, use_container_width=True)
        
        # Scatter plot: Escola vs Taxa de Acerto
        fig = px.scatter(
            taxa_escola,
            x='total_questoes',
            y='taxa_acerto',
            color='DIS_NOME',
            size='total_questoes',
            hover_data=['ESC_NOME', 'MUN_NOME'],
            title="Rela√ß√£o: N√∫mero de Quest√µes vs Taxa de Acerto por Escola"
        )
        fig.update_layout(height=500)
        st.plotly_chart(fig, use_container_width=True)
    
    with tab3:
        st.subheader("Taxa de Acerto por Disciplina")
        
        # Por disciplina e s√©rie
        taxa_disc_serie = df.groupby(['DIS_NOME', 'SER_NOME']).agg({
            'ACERTO': 'sum',
            'ERRO': 'sum'
        }).reset_index()
        taxa_disc_serie['taxa_acerto'] = (taxa_disc_serie['ACERTO'] / (taxa_disc_serie['ACERTO'] + taxa_disc_serie['ERRO']) * 100).round(2)
        
        col1, col2 = st.columns(2)
        
        with col1:
            # Gr√°fico de linhas por s√©rie
            fig = px.line(
                taxa_disc_serie,
                x='SER_NOME',
                y='taxa_acerto',
                color='DIS_NOME',
                title="Evolu√ß√£o da Taxa de Acerto por S√©rie",
                labels={'taxa_acerto': 'Taxa de Acerto (%)', 'SER_NOME': 'S√©rie'},
                markers=True
            )
            fig.update_layout(height=400)
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            # Box plot por disciplina
            fig = px.box(
                df,
                x='DIS_NOME',
                y='taxa_acerto',
                title="Distribui√ß√£o da Taxa de Acerto por Disciplina",
                labels={'taxa_acerto': 'Taxa de Acerto (%)', 'DIS_NOME': 'Disciplina'}
            )
            fig.update_layout(height=400)
            st.plotly_chart(fig, use_container_width=True)
        
        # Por teste
        taxa_teste = df.groupby(['TES_NOME', 'DIS_NOME']).agg({
            'ACERTO': 'sum',
            'ERRO': 'sum'
        }).reset_index()
        taxa_teste['taxa_acerto'] = (taxa_teste['ACERTO'] / (taxa_teste['ACERTO'] + taxa_teste['ERRO']) * 100).round(2)
        
        fig = px.bar(
            taxa_teste,
            x='TES_NOME',
            y='taxa_acerto',
            color='DIS_NOME',
            title="Taxa de Acerto por Teste",
            labels={'taxa_acerto': 'Taxa de Acerto (%)', 'TES_NOME': 'Teste'}
        )
        fig.update_layout(height=500, xaxis_tickangle=-90)
        st.plotly_chart(fig, use_container_width=True)
    
    with tab4:
        st.subheader("Taxa de Acerto por Descritor (Habilidades)")
        
        # Agrupamento por descritor
        taxa_descritor = df.groupby(['MTI_DESCRITOR', 'DIS_NOME']).agg({
            'ACERTO': 'sum',
            'ERRO': 'sum'
        }).reset_index()
        taxa_descritor['total_questoes'] = taxa_descritor['ACERTO'] + taxa_descritor['ERRO']
        taxa_descritor['taxa_acerto'] = (taxa_descritor['ACERTO'] / taxa_descritor['total_questoes'] * 100).round(2)
        
        # Filtrar apenas descritores com dados significativos
        taxa_descritor = taxa_descritor[taxa_descritor['total_questoes'] >= 100]
        
        # Top e Bottom descritores
        col1, col2 = st.columns(2)
        
        with col1:
            # Descritores mais dif√≠ceis
            bottom_descritores = taxa_descritor.nsmallest(15, 'taxa_acerto')
            
            fig = px.bar(
                bottom_descritores,
                x='taxa_acerto',
                y='MTI_DESCRITOR',
                orientation='h',
                color='DIS_NOME',
                title="15 Descritores Mais Dif√≠ceis",
                labels={'taxa_acerto': 'Taxa de Acerto (%)', 'MTI_DESCRITOR': 'Descritor'}
            )
            fig.update_layout(height=500)
            st.plotly_chart(fig, use_container_width=True)
        
        with col2:
            # Descritores mais f√°ceis
            top_descritores = taxa_descritor.nlargest(15, 'taxa_acerto')
            
            fig = px.bar(
                top_descritores,
                x='taxa_acerto',
                y='MTI_DESCRITOR',
                orientation='h',
                color='DIS_NOME',
                title="15 Descritores Mais F√°ceis",
                labels={'taxa_acerto': 'Taxa de Acerto (%)', 'MTI_DESCRITOR': 'Descritor'}
            )
            fig.update_layout(height=500)
            st.plotly_chart(fig, use_container_width=True)
        
        # Histograma de distribui√ß√£o
        fig = px.histogram(
            taxa_descritor,
            x='taxa_acerto',
            color='DIS_NOME',
            title="Distribui√ß√£o das Taxas de Acerto por Descritor",
            labels={'taxa_acerto': 'Taxa de Acerto (%)', 'count': 'N√∫mero de Descritores'},
            nbins=20
        )
        fig.update_layout(height=400)
        st.plotly_chart(fig, use_container_width=True)

# =================== APLICATIVO PRINCIPAL ===================

def main():
    """Fun√ß√£o principal do aplicativo"""
    
    # Cabe√ßalho
    st.title("üìä SAEV - Sistema de An√°lise Educacional")
    st.subheader("üéØ Galeria de Pain√©is com Filtros Avan√ßados")
    st.markdown("---")
    
    # Verificar conex√£o com banco
    con = conectar_banco()
    if not con:
        st.error("‚ùå N√£o foi poss√≠vel conectar ao banco de dados. Verifique se o arquivo 'db/avaliacao_prod.duckdb' existe.")
        return
    con.close()
    
    # Criar filtros na sidebar
    filtros = criar_filtros()
    
    # Verificar se algum filtro foi selecionado
    filtros_aplicados = any(filtros.values())
    
    if not filtros_aplicados:
        st.info("‚ÑπÔ∏è **Selecione ao menos um filtro na barra lateral para visualizar os dados.**")
        st.markdown("""
        ### üìã Como usar este painel:
        
        1. **Selecione os filtros** na barra lateral √† esquerda
        2. **Use m√∫ltipla sele√ß√£o** para comparar diferentes categorias
        3. **Clique em "Todos"** nos filtros de Munic√≠pio e Escola para selecionar tudo
        4. **Explore os dois pain√©is** dispon√≠veis:
           - **Painel 1:** Vis√£o geral com estat√≠sticas e distribui√ß√µes
           - **Painel 2:** An√°lises detalhadas de taxa de acerto
        
        ### üéØ Filtros dispon√≠veis:
        - üìÖ **Ano:** Per√≠odo da avalia√ß√£o
        - üèôÔ∏è **Munic√≠pio:** Localiza√ß√£o geogr√°fica
        - üè´ **Escola:** Institui√ß√£o de ensino
        - üìö **Disciplina:** Mat√©ria avaliada
        - üéì **S√©rie:** Ano escolar
        - üìù **Teste:** Tipo de avalia√ß√£o (Diagn√≥stica, Formativa)
        """)
        return
    
    # Carregar dados com filtros aplicados
    with st.spinner("üìä Carregando dados..."):
        df = carregar_dados_filtrados(filtros)
    
    if df.empty:
        st.warning("‚ö†Ô∏è Nenhum dado encontrado com os filtros selecionados. Tente ajustar os filtros.")
        return
    
    # Mostrar resumo dos filtros aplicados
    st.success(f"‚úÖ **{len(df):,} registros** encontrados com os filtros aplicados")
    
    # Seletor de painel
    painel = st.selectbox(
        "üìã Selecione o painel para visualiza√ß√£o:",
        options=[
            "üìä Painel 1: Vis√£o Geral dos Dados",
            "üìà Painel 2: Taxa de Acerto - An√°lises Detalhadas"
        ]
    )
    
    st.markdown("---")
    
    # Renderizar painel selecionado
    if "Painel 1" in painel:
        painel_visao_geral(df)
    elif "Painel 2" in painel:
        painel_taxas_acerto(df)
    
    # Rodap√©
    st.markdown("---")
    st.markdown(f"""
    <div style='text-align: center; color: #666; font-size: 12px;'>
        üìä SAEV - Sistema de An√°lise Educacional do Esp√≠rito Santo<br>
        üïí √öltima atualiza√ß√£o: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}<br>
        üìà Total de registros no banco: {len(df):,}
    </div>
    """, unsafe_allow_html=True)

# =================== EXECU√á√ÉO ===================

if __name__ == "__main__":
    main()
